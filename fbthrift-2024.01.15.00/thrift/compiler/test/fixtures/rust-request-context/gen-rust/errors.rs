// @generated by Thrift for thrift/compiler/test/fixtures/rust-request-context/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift error definitions for `module`.

/// Error definitions for `MyInteraction`.
pub mod my_interaction {

    pub type PingError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_interaction::PingExn> for
        ::std::result::Result<(), PingError>
    {
        fn from(e: crate::services::my_interaction::PingExn) -> Self {
            match e {
                crate::services::my_interaction::PingExn::Success(res) => {
                    ::std::result::Result::Ok(res)
                }
                crate::services::my_interaction::PingExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(PingError::ApplicationException(aexn)),
            }
        }
    }

}

/// Error definitions for `MyService`.
pub mod my_service {

    pub type PingError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::PingExn> for
        ::std::result::Result<(), PingError>
    {
        fn from(e: crate::services::my_service::PingExn) -> Self {
            match e {
                crate::services::my_service::PingExn::Success(res) => {
                    ::std::result::Result::Ok(res)
                }
                crate::services::my_service::PingExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(PingError::ApplicationException(aexn)),
            }
        }
    }

    pub type GetRandomDataError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::GetRandomDataExn> for
        ::std::result::Result<::std::string::String, GetRandomDataError>
    {
        fn from(e: crate::services::my_service::GetRandomDataExn) -> Self {
            match e {
                crate::services::my_service::GetRandomDataExn::Success(res) => {
                    ::std::result::Result::Ok(res)
                }
                crate::services::my_service::GetRandomDataExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(GetRandomDataError::ApplicationException(aexn)),
            }
        }
    }

    pub type HasDataByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::HasDataByIdExn> for
        ::std::result::Result<::std::primitive::bool, HasDataByIdError>
    {
        fn from(e: crate::services::my_service::HasDataByIdExn) -> Self {
            match e {
                crate::services::my_service::HasDataByIdExn::Success(res) => {
                    ::std::result::Result::Ok(res)
                }
                crate::services::my_service::HasDataByIdExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(HasDataByIdError::ApplicationException(aexn)),
            }
        }
    }

    pub type GetDataByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::GetDataByIdExn> for
        ::std::result::Result<::std::string::String, GetDataByIdError>
    {
        fn from(e: crate::services::my_service::GetDataByIdExn) -> Self {
            match e {
                crate::services::my_service::GetDataByIdExn::Success(res) => {
                    ::std::result::Result::Ok(res)
                }
                crate::services::my_service::GetDataByIdExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(GetDataByIdError::ApplicationException(aexn)),
            }
        }
    }

    pub type PutDataByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::PutDataByIdExn> for
        ::std::result::Result<(), PutDataByIdError>
    {
        fn from(e: crate::services::my_service::PutDataByIdExn) -> Self {
            match e {
                crate::services::my_service::PutDataByIdExn::Success(res) => {
                    ::std::result::Result::Ok(res)
                }
                crate::services::my_service::PutDataByIdExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(PutDataByIdError::ApplicationException(aexn)),
            }
        }
    }

    pub type LobDataByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::LobDataByIdExn> for
        ::std::result::Result<(), LobDataByIdError>
    {
        fn from(e: crate::services::my_service::LobDataByIdExn) -> Self {
            match e {
                crate::services::my_service::LobDataByIdExn::Success(res) => {
                    ::std::result::Result::Ok(res)
                }
                crate::services::my_service::LobDataByIdExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(LobDataByIdError::ApplicationException(aexn)),
            }
        }
    }

    pub type StreamByIdError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdExn> for
        ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::MyStruct, crate::errors::my_service::StreamByIdStreamError>>, StreamByIdError>
    {
        fn from(e: crate::services::my_service::StreamByIdExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let stream = res;
                    ::std::result::Result::Ok(stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed())
                }
                crate::services::my_service::StreamByIdExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdError::ApplicationException(aexn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::my_service::StreamByIdResponseExn> for
        ::std::result::Result<(), StreamByIdError>
    {
        fn from(e: crate::services::my_service::StreamByIdResponseExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::my_service::StreamByIdResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdError::ApplicationException(aexn)),
            }
        }
    }

    pub type StreamByIdStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdStreamExn> for
        ::std::result::Result<crate::types::MyStruct, StreamByIdStreamError>
    {
        fn from(e: crate::services::my_service::StreamByIdStreamExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::my_service::StreamByIdStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdStreamError::ApplicationException(aexn)),
            }
        }
    }

    pub type StreamByIdWithExceptionError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithExceptionExn> for
        ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::MyStruct, crate::errors::my_service::StreamByIdWithExceptionStreamError>>, StreamByIdWithExceptionError>
    {
        fn from(e: crate::services::my_service::StreamByIdWithExceptionExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithExceptionExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let stream = res;
                    ::std::result::Result::Ok(stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed())
                }
                crate::services::my_service::StreamByIdWithExceptionExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdWithExceptionError::ApplicationException(aexn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithExceptionResponseExn> for
        ::std::result::Result<(), StreamByIdWithExceptionError>
    {
        fn from(e: crate::services::my_service::StreamByIdWithExceptionResponseExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithExceptionResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::my_service::StreamByIdWithExceptionResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdWithExceptionError::ApplicationException(aexn)),
            }
        }
    }

    #[derive(Debug)]
    pub enum StreamByIdWithExceptionStreamError {
        e(crate::types::MyException),
        ApplicationException(::fbthrift::types::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for StreamByIdWithExceptionStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "MyService::streamByIdWithException failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "MyService::streamByIdWithException failed with e(MyException)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "MyService::streamByIdWithException failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "MyService::streamByIdWithException failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for StreamByIdWithExceptionStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::MyException> for StreamByIdWithExceptionStreamError {
        fn from(e: crate::types::MyException) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for StreamByIdWithExceptionStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for StreamByIdWithExceptionStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithExceptionStreamExn> for
        ::std::result::Result<crate::types::MyStruct, StreamByIdWithExceptionStreamError>
    {
        fn from(e: crate::services::my_service::StreamByIdWithExceptionStreamExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithExceptionStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::my_service::StreamByIdWithExceptionStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdWithExceptionStreamError::ApplicationException(aexn)),
                crate::services::my_service::StreamByIdWithExceptionStreamExn::e(exn) =>
                    ::std::result::Result::Err(StreamByIdWithExceptionStreamError::e(exn)),
            }
        }
    }

    pub type StreamByIdWithResponseError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithResponseExn> for
        ::std::result::Result<(crate::types::MyDataItem, ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::MyStruct, crate::errors::my_service::StreamByIdWithResponseStreamError>>), StreamByIdWithResponseError>
    {
        fn from(e: crate::services::my_service::StreamByIdWithResponseExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithResponseExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let (resp, stream) = res;
                    ::std::result::Result::Ok((resp, stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed()))
                }
                crate::services::my_service::StreamByIdWithResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdWithResponseError::ApplicationException(aexn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithResponseResponseExn> for
        ::std::result::Result<crate::types::MyDataItem, StreamByIdWithResponseError>
    {
        fn from(e: crate::services::my_service::StreamByIdWithResponseResponseExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithResponseResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::my_service::StreamByIdWithResponseResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdWithResponseError::ApplicationException(aexn)),
            }
        }
    }

    pub type StreamByIdWithResponseStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StreamByIdWithResponseStreamExn> for
        ::std::result::Result<crate::types::MyStruct, StreamByIdWithResponseStreamError>
    {
        fn from(e: crate::services::my_service::StreamByIdWithResponseStreamExn) -> Self {
            match e {
                crate::services::my_service::StreamByIdWithResponseStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::my_service::StreamByIdWithResponseStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamByIdWithResponseStreamError::ApplicationException(aexn)),
            }
        }
    }

    pub type StartPingInteractionError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::my_service::StartPingInteractionExn> for
        ::std::result::Result<(), StartPingInteractionError>
    {
        fn from(e: crate::services::my_service::StartPingInteractionExn) -> Self {
            match e {
                crate::services::my_service::StartPingInteractionExn::Success(res) => {
                    ::std::result::Result::Ok(res)
                }
                crate::services::my_service::StartPingInteractionExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StartPingInteractionError::ApplicationException(aexn)),
            }
        }
    }

}

