
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT
 *  @generated
 *
 */

#include <folly/python/import.h>
#include <thrift/lib/python/capi/iobuf.h>
#include <thrift/lib/python/types.h>

#include <thrift/compiler/test/fixtures/enums/src/gen-python-capi/module/thrift_types_api.h>
#include <thrift/compiler/test/fixtures/enums/src/gen-python-capi/module/thrift_types_capi.h>


namespace apache {
namespace thrift {
namespace python {
namespace capi {
namespace {
bool ensure_module_imported() {
  static ::folly::python::import_cache_nocapture import((
      ::import_test__fixtures__enums__module__thrift_types_capi));
  return import();
}
  static constexpr std::int16_t _fbthrift__SomeStruct__tuple_pos[4] = {
    1, 2, 3, 4
  };
  static constexpr std::int16_t _fbthrift__MyStruct__tuple_pos[4] = {
    1, 2, 3, 4
  };
} // namespace

ExtractorResult<::test::fixtures::enums::SomeStruct>
Extractor<::test::fixtures::enums::SomeStruct>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a SomeStruct");
      }
      return extractorError<::test::fixtures::enums::SomeStruct>(
          "Marshal error: SomeStruct");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::test::fixtures::enums::SomeStruct>>{}(*fbThriftData);
}

ExtractorResult<::test::fixtures::enums::SomeStruct>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::test::fixtures::enums::SomeStruct>>::operator()(PyObject* fbThriftData) {
  ::test::fixtures::enums::SomeStruct cpp;
  std::optional<std::string_view> error;
  Extractor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::Metasyntactic>>{}.extractInto(
      cpp.reasonable_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__SomeStruct__tuple_pos[0]),
      error);
  Extractor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::Metasyntactic>>{}.extractInto(
      cpp.fine_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__SomeStruct__tuple_pos[1]),
      error);
  Extractor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::Metasyntactic>>{}.extractInto(
      cpp.questionable_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__SomeStruct__tuple_pos[2]),
      error);
  Extractor<set<int32_t>>{}.extractInto(
      cpp.tags_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__SomeStruct__tuple_pos[3]),
      error);
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::test::fixtures::enums::SomeStruct>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__SomeStruct(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: SomeStruct");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::SomeStruct>::operator()(
    const ::test::fixtures::enums::SomeStruct& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::test::fixtures::enums::SomeStruct>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__test__fixtures__enums__module__SomeStruct(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::test::fixtures::enums::SomeStruct>>::operator()(
    FOLLY_MAYBE_UNUSED const ::test::fixtures::enums::SomeStruct& val) {
  StrongRef fbthrift_data(createStructTuple(4));
  StrongRef _fbthrift__reasonable(
    Constructor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::Metasyntactic>>{}
    .constructFrom(val.reasonable_ref()));
  if (!_fbthrift__reasonable ||
      setStructField(
          *fbthrift_data,
          _fbthrift__SomeStruct__tuple_pos[0],
          *_fbthrift__reasonable) == -1) {
    return nullptr;
  }
  StrongRef _fbthrift__fine(
    Constructor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::Metasyntactic>>{}
    .constructFrom(val.fine_ref()));
  if (!_fbthrift__fine ||
      setStructField(
          *fbthrift_data,
          _fbthrift__SomeStruct__tuple_pos[1],
          *_fbthrift__fine) == -1) {
    return nullptr;
  }
  StrongRef _fbthrift__questionable(
    Constructor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::Metasyntactic>>{}
    .constructFrom(val.questionable_ref()));
  if (!_fbthrift__questionable ||
      setStructField(
          *fbthrift_data,
          _fbthrift__SomeStruct__tuple_pos[2],
          *_fbthrift__questionable) == -1) {
    return nullptr;
  }
  StrongRef _fbthrift__tags(
    Constructor<set<int32_t>>{}
    .constructFrom(val.tags_ref()));
  if (!_fbthrift__tags ||
      setStructField(
          *fbthrift_data,
          _fbthrift__SomeStruct__tuple_pos[3],
          *_fbthrift__tags) == -1) {
    return nullptr;
  }
  return std::move(fbthrift_data).release();
}


ExtractorResult<::test::fixtures::enums::MyStruct>
Extractor<::test::fixtures::enums::MyStruct>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a MyStruct");
      }
      return extractorError<::test::fixtures::enums::MyStruct>(
          "Marshal error: MyStruct");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::test::fixtures::enums::MyStruct>>{}(*fbThriftData);
}

ExtractorResult<::test::fixtures::enums::MyStruct>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::test::fixtures::enums::MyStruct>>::operator()(PyObject* fbThriftData) {
  ::test::fixtures::enums::MyStruct cpp;
  std::optional<std::string_view> error;
  Extractor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::MyEnum2>>{}.extractInto(
      cpp.me2_3_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__MyStruct__tuple_pos[0]),
      error);
  Extractor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::MyEnum3>>{}.extractInto(
      cpp.me3_n3_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__MyStruct__tuple_pos[1]),
      error);
  Extractor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::MyEnum1>>{}.extractInto(
      cpp.me1_t1_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__MyStruct__tuple_pos[2]),
      error);
  Extractor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::MyEnum1>>{}.extractInto(
      cpp.me1_t2_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__MyStruct__tuple_pos[3]),
      error);
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::test::fixtures::enums::MyStruct>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__MyStruct(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: MyStruct");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::MyStruct>::operator()(
    const ::test::fixtures::enums::MyStruct& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::test::fixtures::enums::MyStruct>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__test__fixtures__enums__module__MyStruct(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::test::fixtures::enums::MyStruct>>::operator()(
    FOLLY_MAYBE_UNUSED const ::test::fixtures::enums::MyStruct& val) {
  StrongRef fbthrift_data(createStructTuple(4));
  StrongRef _fbthrift__me2_3(
    Constructor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::MyEnum2>>{}
    .constructFrom(val.me2_3_ref()));
  if (!_fbthrift__me2_3 ||
      setStructField(
          *fbthrift_data,
          _fbthrift__MyStruct__tuple_pos[0],
          *_fbthrift__me2_3) == -1) {
    return nullptr;
  }
  StrongRef _fbthrift__me3_n3(
    Constructor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::MyEnum3>>{}
    .constructFrom(val.me3_n3_ref()));
  if (!_fbthrift__me3_n3 ||
      setStructField(
          *fbthrift_data,
          _fbthrift__MyStruct__tuple_pos[1],
          *_fbthrift__me3_n3) == -1) {
    return nullptr;
  }
  StrongRef _fbthrift__me1_t1(
    Constructor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::MyEnum1>>{}
    .constructFrom(val.me1_t1_ref()));
  if (!_fbthrift__me1_t1 ||
      setStructField(
          *fbthrift_data,
          _fbthrift__MyStruct__tuple_pos[2],
          *_fbthrift__me1_t1) == -1) {
    return nullptr;
  }
  StrongRef _fbthrift__me1_t2(
    Constructor<::apache::thrift::python::capi::ComposedEnum<::test::fixtures::enums::MyEnum1>>{}
    .constructFrom(val.me1_t2_ref()));
  if (!_fbthrift__me1_t2 ||
      setStructField(
          *fbthrift_data,
          _fbthrift__MyStruct__tuple_pos[3],
          *_fbthrift__me1_t2) == -1) {
    return nullptr;
  }
  return std::move(fbthrift_data).release();
}


ExtractorResult<::test::fixtures::enums::Metasyntactic>
Extractor<::test::fixtures::enums::Metasyntactic>::operator()(PyObject* obj) {
  long val = PyLong_AsLong(obj);
  if (val == -1 && PyErr_Occurred()) {
    return extractorError<::test::fixtures::enums::Metasyntactic>(
        "Error getting python int value: Metasyntactic");
  }
  return static_cast<::test::fixtures::enums::Metasyntactic>(val);
}

int Extractor<::test::fixtures::enums::Metasyntactic>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__Metasyntactic(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: Metasyntactic");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::Metasyntactic>::operator()(
    ::test::fixtures::enums::Metasyntactic val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  auto ptr = construct__test__fixtures__enums__module__Metasyntactic(
      static_cast<int64_t>(val));
  if (!ptr) {
    CHECK(PyErr_Occurred());
  }
  return ptr;
}

ExtractorResult<::test::fixtures::enums::MyEnum1>
Extractor<::test::fixtures::enums::MyEnum1>::operator()(PyObject* obj) {
  long val = PyLong_AsLong(obj);
  if (val == -1 && PyErr_Occurred()) {
    return extractorError<::test::fixtures::enums::MyEnum1>(
        "Error getting python int value: MyEnum1");
  }
  return static_cast<::test::fixtures::enums::MyEnum1>(val);
}

int Extractor<::test::fixtures::enums::MyEnum1>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__MyEnum1(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: MyEnum1");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::MyEnum1>::operator()(
    ::test::fixtures::enums::MyEnum1 val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  auto ptr = construct__test__fixtures__enums__module__MyEnum1(
      static_cast<int64_t>(val));
  if (!ptr) {
    CHECK(PyErr_Occurred());
  }
  return ptr;
}

ExtractorResult<::test::fixtures::enums::MyEnum2>
Extractor<::test::fixtures::enums::MyEnum2>::operator()(PyObject* obj) {
  long val = PyLong_AsLong(obj);
  if (val == -1 && PyErr_Occurred()) {
    return extractorError<::test::fixtures::enums::MyEnum2>(
        "Error getting python int value: MyEnum2");
  }
  return static_cast<::test::fixtures::enums::MyEnum2>(val);
}

int Extractor<::test::fixtures::enums::MyEnum2>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__MyEnum2(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: MyEnum2");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::MyEnum2>::operator()(
    ::test::fixtures::enums::MyEnum2 val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  auto ptr = construct__test__fixtures__enums__module__MyEnum2(
      static_cast<int64_t>(val));
  if (!ptr) {
    CHECK(PyErr_Occurred());
  }
  return ptr;
}

ExtractorResult<::test::fixtures::enums::MyEnum3>
Extractor<::test::fixtures::enums::MyEnum3>::operator()(PyObject* obj) {
  long val = PyLong_AsLong(obj);
  if (val == -1 && PyErr_Occurred()) {
    return extractorError<::test::fixtures::enums::MyEnum3>(
        "Error getting python int value: MyEnum3");
  }
  return static_cast<::test::fixtures::enums::MyEnum3>(val);
}

int Extractor<::test::fixtures::enums::MyEnum3>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__MyEnum3(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: MyEnum3");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::MyEnum3>::operator()(
    ::test::fixtures::enums::MyEnum3 val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  auto ptr = construct__test__fixtures__enums__module__MyEnum3(
      static_cast<int64_t>(val));
  if (!ptr) {
    CHECK(PyErr_Occurred());
  }
  return ptr;
}

ExtractorResult<::test::fixtures::enums::MyEnum4>
Extractor<::test::fixtures::enums::MyEnum4>::operator()(PyObject* obj) {
  long val = PyLong_AsLong(obj);
  if (val == -1 && PyErr_Occurred()) {
    return extractorError<::test::fixtures::enums::MyEnum4>(
        "Error getting python int value: MyEnum4");
  }
  return static_cast<::test::fixtures::enums::MyEnum4>(val);
}

int Extractor<::test::fixtures::enums::MyEnum4>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__MyEnum4(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: MyEnum4");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::MyEnum4>::operator()(
    ::test::fixtures::enums::MyEnum4 val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  auto ptr = construct__test__fixtures__enums__module__MyEnum4(
      static_cast<int64_t>(val));
  if (!ptr) {
    CHECK(PyErr_Occurred());
  }
  return ptr;
}

ExtractorResult<::test::fixtures::enums::MyBitmaskEnum1>
Extractor<::test::fixtures::enums::MyBitmaskEnum1>::operator()(PyObject* obj) {
  long val = PyLong_AsLong(obj);
  if (val == -1 && PyErr_Occurred()) {
    return extractorError<::test::fixtures::enums::MyBitmaskEnum1>(
        "Error getting python int value: MyBitmaskEnum1");
  }
  return static_cast<::test::fixtures::enums::MyBitmaskEnum1>(val);
}

int Extractor<::test::fixtures::enums::MyBitmaskEnum1>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__MyBitmaskEnum1(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: MyBitmaskEnum1");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::MyBitmaskEnum1>::operator()(
    ::test::fixtures::enums::MyBitmaskEnum1 val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  auto ptr = construct__test__fixtures__enums__module__MyBitmaskEnum1(
      static_cast<int64_t>(val));
  if (!ptr) {
    CHECK(PyErr_Occurred());
  }
  return ptr;
}

ExtractorResult<::test::fixtures::enums::MyBitmaskEnum2>
Extractor<::test::fixtures::enums::MyBitmaskEnum2>::operator()(PyObject* obj) {
  long val = PyLong_AsLong(obj);
  if (val == -1 && PyErr_Occurred()) {
    return extractorError<::test::fixtures::enums::MyBitmaskEnum2>(
        "Error getting python int value: MyBitmaskEnum2");
  }
  return static_cast<::test::fixtures::enums::MyBitmaskEnum2>(val);
}

int Extractor<::test::fixtures::enums::MyBitmaskEnum2>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module test.fixtures.enums.module import error");
  }
  int result =
      can_extract__test__fixtures__enums__module__MyBitmaskEnum2(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: MyBitmaskEnum2");
  }
  return result;
}


PyObject* Constructor<::test::fixtures::enums::MyBitmaskEnum2>::operator()(
    ::test::fixtures::enums::MyBitmaskEnum2 val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  auto ptr = construct__test__fixtures__enums__module__MyBitmaskEnum2(
      static_cast<int64_t>(val));
  if (!ptr) {
    CHECK(PyErr_Occurred());
  }
  return ptr;
}

} // namespace capi
} // namespace python
} // namespace thrift
} // namespace apache
