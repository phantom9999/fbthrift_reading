
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT
 *  @generated
 *
 */

#include <folly/python/import.h>
#include <thrift/lib/python/capi/iobuf.h>
#include <thrift/lib/python/types.h>

#include <thrift/compiler/test/fixtures/complex-union/src/gen-python-capi/module/thrift_types_api.h>
#include <thrift/compiler/test/fixtures/complex-union/src/gen-python-capi/module/thrift_types_capi.h>


namespace apache {
namespace thrift {
namespace python {
namespace capi {
namespace {
bool ensure_module_imported() {
  static ::folly::python::import_cache_nocapture import((
      ::import_module__thrift_types_capi));
  return import();
}
  static constexpr std::int16_t _fbthrift__Val__tuple_pos[3] = {
    1, 2, 3
  };
  static constexpr std::int16_t _fbthrift__NonCopyableStruct__tuple_pos[1] = {
    1
  };
} // namespace

ExtractorResult<::cpp2::ComplexUnion>
Extractor<::cpp2::ComplexUnion>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a ComplexUnion");
      }
      return extractorError<::cpp2::ComplexUnion>(
          "Marshal error: ComplexUnion");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::cpp2::ComplexUnion>>{}(*fbThriftData);
}

ExtractorResult<::cpp2::ComplexUnion>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::cpp2::ComplexUnion>>::operator()(PyObject* fbThriftData) {
  ::cpp2::ComplexUnion cpp;
  std::optional<std::string_view> error;
  auto type_tag = Extractor<int64_t>{}(PyTuple_GET_ITEM(fbThriftData, 0));
  if (type_tag.hasError()) {
    return folly::makeUnexpected(type_tag.error());
  }
  switch (*type_tag) {
    case 0:
      break; // union is unset
    case 1:
      Extractor<int64_t>{}.extractInto(
          cpp.intValue_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 5:
      Extractor<Bytes>{}.extractInto(
          cpp.stringValue_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 2:
      Extractor<list<int64_t>>{}.extractInto(
          cpp.intListValue_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 3:
      Extractor<list<Bytes>>{}.extractInto(
          cpp.stringListValue_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 9:
      Extractor<map<int16_t, Bytes>>{}.extractInto(
          cpp.typedefValue_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 14:
      Extractor<Bytes>{}.extractInto(
          cpp.stringRef_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
  }
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::cpp2::ComplexUnion>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module module import error");
  }
  int result =
      can_extract__module__ComplexUnion(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: ComplexUnion");
  }
  return result;
}


PyObject* Constructor<::cpp2::ComplexUnion>::operator()(
    const ::cpp2::ComplexUnion& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::ComplexUnion>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__module__ComplexUnion(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::ComplexUnion>>::operator()(
    FOLLY_MAYBE_UNUSED const ::cpp2::ComplexUnion& val) {
  int64_t type_key = static_cast<int64_t>(val.getType());
  StrongRef py_val;
  switch (type_key) {
    case 0:
      Py_INCREF(Py_None);
      py_val = StrongRef(Py_None);
      break;
    case 1:
      py_val = StrongRef(
          Constructor<int64_t>{}
          .constructFrom(val.intValue_ref()));
      break;
    case 5:
      py_val = StrongRef(
          Constructor<Bytes>{}
          .constructFrom(val.stringValue_ref()));
      break;
    case 2:
      py_val = StrongRef(
          Constructor<list<int64_t>>{}
          .constructFrom(val.intListValue_ref()));
      break;
    case 3:
      py_val = StrongRef(
          Constructor<list<Bytes>>{}
          .constructFrom(val.stringListValue_ref()));
      break;
    case 9:
      py_val = StrongRef(
          Constructor<map<int16_t, Bytes>>{}
          .constructFrom(val.typedefValue_ref()));
      break;
    case 14:
      py_val = StrongRef(
          Constructor<Bytes>{}
          .constructFrom(val.stringRef_ref()));
      break;
  }
  if (!py_val) {
    return nullptr;
  }
  return unionTupleFromValue(type_key, *py_val);
}


ExtractorResult<::cpp2::ListUnion>
Extractor<::cpp2::ListUnion>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a ListUnion");
      }
      return extractorError<::cpp2::ListUnion>(
          "Marshal error: ListUnion");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::cpp2::ListUnion>>{}(*fbThriftData);
}

ExtractorResult<::cpp2::ListUnion>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::cpp2::ListUnion>>::operator()(PyObject* fbThriftData) {
  ::cpp2::ListUnion cpp;
  std::optional<std::string_view> error;
  auto type_tag = Extractor<int64_t>{}(PyTuple_GET_ITEM(fbThriftData, 0));
  if (type_tag.hasError()) {
    return folly::makeUnexpected(type_tag.error());
  }
  switch (*type_tag) {
    case 0:
      break; // union is unset
    case 2:
      Extractor<list<int64_t>>{}.extractInto(
          cpp.intListValue_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 3:
      Extractor<list<Bytes>>{}.extractInto(
          cpp.stringListValue_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
  }
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::cpp2::ListUnion>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module module import error");
  }
  int result =
      can_extract__module__ListUnion(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: ListUnion");
  }
  return result;
}


PyObject* Constructor<::cpp2::ListUnion>::operator()(
    const ::cpp2::ListUnion& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::ListUnion>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__module__ListUnion(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::ListUnion>>::operator()(
    FOLLY_MAYBE_UNUSED const ::cpp2::ListUnion& val) {
  int64_t type_key = static_cast<int64_t>(val.getType());
  StrongRef py_val;
  switch (type_key) {
    case 0:
      Py_INCREF(Py_None);
      py_val = StrongRef(Py_None);
      break;
    case 2:
      py_val = StrongRef(
          Constructor<list<int64_t>>{}
          .constructFrom(val.intListValue_ref()));
      break;
    case 3:
      py_val = StrongRef(
          Constructor<list<Bytes>>{}
          .constructFrom(val.stringListValue_ref()));
      break;
  }
  if (!py_val) {
    return nullptr;
  }
  return unionTupleFromValue(type_key, *py_val);
}


ExtractorResult<::cpp2::DataUnion>
Extractor<::cpp2::DataUnion>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a DataUnion");
      }
      return extractorError<::cpp2::DataUnion>(
          "Marshal error: DataUnion");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::cpp2::DataUnion>>{}(*fbThriftData);
}

ExtractorResult<::cpp2::DataUnion>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::cpp2::DataUnion>>::operator()(PyObject* fbThriftData) {
  ::cpp2::DataUnion cpp;
  std::optional<std::string_view> error;
  auto type_tag = Extractor<int64_t>{}(PyTuple_GET_ITEM(fbThriftData, 0));
  if (type_tag.hasError()) {
    return folly::makeUnexpected(type_tag.error());
  }
  switch (*type_tag) {
    case 0:
      break; // union is unset
    case 1:
      Extractor<Bytes>{}.extractInto(
          cpp.binaryData_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 2:
      Extractor<Bytes>{}.extractInto(
          cpp.stringData_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
  }
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::cpp2::DataUnion>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module module import error");
  }
  int result =
      can_extract__module__DataUnion(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: DataUnion");
  }
  return result;
}


PyObject* Constructor<::cpp2::DataUnion>::operator()(
    const ::cpp2::DataUnion& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::DataUnion>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__module__DataUnion(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::DataUnion>>::operator()(
    FOLLY_MAYBE_UNUSED const ::cpp2::DataUnion& val) {
  int64_t type_key = static_cast<int64_t>(val.getType());
  StrongRef py_val;
  switch (type_key) {
    case 0:
      Py_INCREF(Py_None);
      py_val = StrongRef(Py_None);
      break;
    case 1:
      py_val = StrongRef(
          Constructor<Bytes>{}
          .constructFrom(val.binaryData_ref()));
      break;
    case 2:
      py_val = StrongRef(
          Constructor<Bytes>{}
          .constructFrom(val.stringData_ref()));
      break;
  }
  if (!py_val) {
    return nullptr;
  }
  return unionTupleFromValue(type_key, *py_val);
}


ExtractorResult<::cpp2::Val>
Extractor<::cpp2::Val>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a Val");
      }
      return extractorError<::cpp2::Val>(
          "Marshal error: Val");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::cpp2::Val>>{}(*fbThriftData);
}

ExtractorResult<::cpp2::Val>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::cpp2::Val>>::operator()(PyObject* fbThriftData) {
  ::cpp2::Val cpp;
  std::optional<std::string_view> error;
  Extractor<Bytes>{}.extractInto(
      cpp.strVal_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__Val__tuple_pos[0]),
      error);
  Extractor<int32_t>{}.extractInto(
      cpp.intVal_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__Val__tuple_pos[1]),
      error);
  Extractor<map<int16_t, Bytes>>{}.extractInto(
      cpp.typedefValue_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__Val__tuple_pos[2]),
      error);
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::cpp2::Val>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module module import error");
  }
  int result =
      can_extract__module__Val(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: Val");
  }
  return result;
}


PyObject* Constructor<::cpp2::Val>::operator()(
    const ::cpp2::Val& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::Val>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__module__Val(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::Val>>::operator()(
    FOLLY_MAYBE_UNUSED const ::cpp2::Val& val) {
  StrongRef fbthrift_data(createStructTuple(3));
  StrongRef _fbthrift__strVal(
    Constructor<Bytes>{}
    .constructFrom(val.strVal_ref()));
  if (!_fbthrift__strVal ||
      setStructField(
          *fbthrift_data,
          _fbthrift__Val__tuple_pos[0],
          *_fbthrift__strVal) == -1) {
    return nullptr;
  }
  StrongRef _fbthrift__intVal(
    Constructor<int32_t>{}
    .constructFrom(val.intVal_ref()));
  if (!_fbthrift__intVal ||
      setStructField(
          *fbthrift_data,
          _fbthrift__Val__tuple_pos[1],
          *_fbthrift__intVal) == -1) {
    return nullptr;
  }
  StrongRef _fbthrift__typedefValue(
    Constructor<map<int16_t, Bytes>>{}
    .constructFrom(val.typedefValue_ref()));
  if (!_fbthrift__typedefValue ||
      setStructField(
          *fbthrift_data,
          _fbthrift__Val__tuple_pos[2],
          *_fbthrift__typedefValue) == -1) {
    return nullptr;
  }
  return std::move(fbthrift_data).release();
}


ExtractorResult<::cpp2::ValUnion>
Extractor<::cpp2::ValUnion>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a ValUnion");
      }
      return extractorError<::cpp2::ValUnion>(
          "Marshal error: ValUnion");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::cpp2::ValUnion>>{}(*fbThriftData);
}

ExtractorResult<::cpp2::ValUnion>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::cpp2::ValUnion>>::operator()(PyObject* fbThriftData) {
  ::cpp2::ValUnion cpp;
  std::optional<std::string_view> error;
  auto type_tag = Extractor<int64_t>{}(PyTuple_GET_ITEM(fbThriftData, 0));
  if (type_tag.hasError()) {
    return folly::makeUnexpected(type_tag.error());
  }
  switch (*type_tag) {
    case 0:
      break; // union is unset
    case 1:
      Extractor<::apache::thrift::python::capi::ComposedStruct<::cpp2::Val>>{}.extractInto(
          cpp.v1_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 2:
      Extractor<::apache::thrift::python::capi::ComposedStruct<::cpp2::Val>>{}.extractInto(
          cpp.v2_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
  }
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::cpp2::ValUnion>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module module import error");
  }
  int result =
      can_extract__module__ValUnion(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: ValUnion");
  }
  return result;
}


PyObject* Constructor<::cpp2::ValUnion>::operator()(
    const ::cpp2::ValUnion& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::ValUnion>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__module__ValUnion(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::ValUnion>>::operator()(
    FOLLY_MAYBE_UNUSED const ::cpp2::ValUnion& val) {
  int64_t type_key = static_cast<int64_t>(val.getType());
  StrongRef py_val;
  switch (type_key) {
    case 0:
      Py_INCREF(Py_None);
      py_val = StrongRef(Py_None);
      break;
    case 1:
      py_val = StrongRef(
          Constructor<::apache::thrift::python::capi::ComposedStruct<::cpp2::Val>>{}
          .constructFrom(val.v1_ref()));
      break;
    case 2:
      py_val = StrongRef(
          Constructor<::apache::thrift::python::capi::ComposedStruct<::cpp2::Val>>{}
          .constructFrom(val.v2_ref()));
      break;
  }
  if (!py_val) {
    return nullptr;
  }
  return unionTupleFromValue(type_key, *py_val);
}


ExtractorResult<::cpp2::VirtualComplexUnion>
Extractor<::cpp2::VirtualComplexUnion>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a VirtualComplexUnion");
      }
      return extractorError<::cpp2::VirtualComplexUnion>(
          "Marshal error: VirtualComplexUnion");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::cpp2::VirtualComplexUnion>>{}(*fbThriftData);
}

ExtractorResult<::cpp2::VirtualComplexUnion>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::cpp2::VirtualComplexUnion>>::operator()(PyObject* fbThriftData) {
  ::cpp2::VirtualComplexUnion cpp;
  std::optional<std::string_view> error;
  auto type_tag = Extractor<int64_t>{}(PyTuple_GET_ITEM(fbThriftData, 0));
  if (type_tag.hasError()) {
    return folly::makeUnexpected(type_tag.error());
  }
  switch (*type_tag) {
    case 0:
      break; // union is unset
    case 1:
      Extractor<Bytes>{}.extractInto(
          cpp.thingOne_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
    case 2:
      Extractor<Bytes>{}.extractInto(
          cpp.thingTwo_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
  }
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::cpp2::VirtualComplexUnion>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module module import error");
  }
  int result =
      can_extract__module__VirtualComplexUnion(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: VirtualComplexUnion");
  }
  return result;
}


PyObject* Constructor<::cpp2::VirtualComplexUnion>::operator()(
    const ::cpp2::VirtualComplexUnion& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::VirtualComplexUnion>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__module__VirtualComplexUnion(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::VirtualComplexUnion>>::operator()(
    FOLLY_MAYBE_UNUSED const ::cpp2::VirtualComplexUnion& val) {
  int64_t type_key = static_cast<int64_t>(val.getType());
  StrongRef py_val;
  switch (type_key) {
    case 0:
      Py_INCREF(Py_None);
      py_val = StrongRef(Py_None);
      break;
    case 1:
      py_val = StrongRef(
          Constructor<Bytes>{}
          .constructFrom(val.thingOne_ref()));
      break;
    case 2:
      py_val = StrongRef(
          Constructor<Bytes>{}
          .constructFrom(val.thingTwo_ref()));
      break;
  }
  if (!py_val) {
    return nullptr;
  }
  return unionTupleFromValue(type_key, *py_val);
}


ExtractorResult<::cpp2::NonCopyableStruct>
Extractor<::cpp2::NonCopyableStruct>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a NonCopyableStruct");
      }
      return extractorError<::cpp2::NonCopyableStruct>(
          "Marshal error: NonCopyableStruct");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::cpp2::NonCopyableStruct>>{}(*fbThriftData);
}

ExtractorResult<::cpp2::NonCopyableStruct>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::cpp2::NonCopyableStruct>>::operator()(PyObject* fbThriftData) {
  ::cpp2::NonCopyableStruct cpp;
  std::optional<std::string_view> error;
  Extractor<int64_t>{}.extractInto(
      cpp.num_ref(),
      PyTuple_GET_ITEM(fbThriftData, _fbthrift__NonCopyableStruct__tuple_pos[0]),
      error);
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::cpp2::NonCopyableStruct>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module module import error");
  }
  int result =
      can_extract__module__NonCopyableStruct(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: NonCopyableStruct");
  }
  return result;
}


PyObject* Constructor<::cpp2::NonCopyableStruct>::operator()(
    const ::cpp2::NonCopyableStruct& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::NonCopyableStruct>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__module__NonCopyableStruct(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::NonCopyableStruct>>::operator()(
    FOLLY_MAYBE_UNUSED const ::cpp2::NonCopyableStruct& val) {
  StrongRef fbthrift_data(createStructTuple(1));
  StrongRef _fbthrift__num(
    Constructor<int64_t>{}
    .constructFrom(val.num_ref()));
  if (!_fbthrift__num ||
      setStructField(
          *fbthrift_data,
          _fbthrift__NonCopyableStruct__tuple_pos[0],
          *_fbthrift__num) == -1) {
    return nullptr;
  }
  return std::move(fbthrift_data).release();
}


ExtractorResult<::cpp2::NonCopyableUnion>
Extractor<::cpp2::NonCopyableUnion>::operator()(PyObject* obj) {
  int tCheckResult = typeCheck(obj);
  if (tCheckResult != 1) {
      if (tCheckResult == 0) {
        PyErr_SetString(PyExc_TypeError, "Not a NonCopyableUnion");
      }
      return extractorError<::cpp2::NonCopyableUnion>(
          "Marshal error: NonCopyableUnion");
  }
  StrongRef fbThriftData(getThriftData(obj));
  return Extractor<::apache::thrift::python::capi::ComposedStruct<
      ::cpp2::NonCopyableUnion>>{}(*fbThriftData);
}

ExtractorResult<::cpp2::NonCopyableUnion>
Extractor<::apache::thrift::python::capi::ComposedStruct<
    ::cpp2::NonCopyableUnion>>::operator()(PyObject* fbThriftData) {
  ::cpp2::NonCopyableUnion cpp;
  std::optional<std::string_view> error;
  auto type_tag = Extractor<int64_t>{}(PyTuple_GET_ITEM(fbThriftData, 0));
  if (type_tag.hasError()) {
    return folly::makeUnexpected(type_tag.error());
  }
  switch (*type_tag) {
    case 0:
      break; // union is unset
    case 1:
      Extractor<::apache::thrift::python::capi::ComposedStruct<::cpp2::NonCopyableStruct>>{}.extractInto(
          cpp.s_ref(), PyTuple_GET_ITEM(fbThriftData, 1), error);
      break;
  }
  if (error) {
    return folly::makeUnexpected(*error);
  }
  return cpp;
}


int Extractor<::cpp2::NonCopyableUnion>::typeCheck(PyObject* obj) {
  if (!ensure_module_imported()) {
    ::folly::python::handlePythonError(
      "Module module import error");
  }
  int result =
      can_extract__module__NonCopyableUnion(obj);
  if (result < 0) {
    ::folly::python::handlePythonError(
      "Unexpected type check error: NonCopyableUnion");
  }
  return result;
}


PyObject* Constructor<::cpp2::NonCopyableUnion>::operator()(
    const ::cpp2::NonCopyableUnion& val) {
  if (!ensure_module_imported()) {
    DCHECK(PyErr_Occurred() != nullptr);
    return nullptr;
  }
  Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::NonCopyableUnion>> ctor;
  StrongRef fbthrift_data(ctor(val));
  if (!fbthrift_data) {
    return nullptr;
  }
  return init__module__NonCopyableUnion(*fbthrift_data);
}

PyObject* Constructor<::apache::thrift::python::capi::ComposedStruct<
        ::cpp2::NonCopyableUnion>>::operator()(
    FOLLY_MAYBE_UNUSED const ::cpp2::NonCopyableUnion& val) {
  int64_t type_key = static_cast<int64_t>(val.getType());
  StrongRef py_val;
  switch (type_key) {
    case 0:
      Py_INCREF(Py_None);
      py_val = StrongRef(Py_None);
      break;
    case 1:
      py_val = StrongRef(
          Constructor<::apache::thrift::python::capi::ComposedStruct<::cpp2::NonCopyableStruct>>{}
          .constructFrom(val.s_ref()));
      break;
  }
  if (!py_val) {
    return nullptr;
  }
  return unionTupleFromValue(type_key, *py_val);
}


} // namespace capi
} // namespace python
} // namespace thrift
} // namespace apache
